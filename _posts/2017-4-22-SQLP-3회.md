---
layout: post
title: Lock과 트랜잭션 동시성 제어
category: SQL
tags: [SQLP][SQL]
---
## Lock ##
- 공유 Lock
  - 데이터 읽기
  - 공유 Lock과는 호환, 베타적 Lock과는 호환되지 않음

- 베타적 Lock
  - 데이터 변경
  - 베타적 Lock 설정시 읽기 불가 변경 불가, 반대로 다른 Lock 설정시 베타적 Lock 설정불가

- 블로킹
  - lock 경합
  - 해소는 Commit 또는 Rollback
  > 성능 저하 최소화 방안
  - 원자성을 해소하지 않는 선에서 트랜잭션을 짧게  
  - 같은 데이터를 동시 갱신하지 않도록 설계  
  - select for update [nowait | wait 3]
  - 트랜잭션 격리성 수준 불필요하게 상향 조정하지 않음
  - SQL 문장이 가장 빠른 시간내에 완료하도록 함.

- 교착상태
 - 성능 저하 최소화 방안
 - 여러 테이블 접근시 접근 순서 일치

- Oracle Lock :
DML Lock, DDL Lock, Latch, 버퍼 Lock, 라이브러리 캐쉬 Lock/Pin
  - 로우 Lock : insert, update, delete, select.. for update
    - 읽을려는 데이타를 다른 트랜잭션이 갱신중이여도 기다리지않음.
    - 갱신하려는 데이터를 다른 트랜잭션이 읽는 중이라도 기다리지 않음.
    - 갱신하려는 데이터를 다른 트랜잭션이 갱신 중미면 대기.

  - 테이블 Lock : 로우 Lock 획득시 동싱에 테이블 Lock 획득(Flag)
    - Row Share(RS) : select .. for update
    - Row Exclusive(RX) : insert, update, delete
    - Share(S)
    - Share Row Exclusive(RSX)
    - Exclusive(X)

    ```SQL
    // 명시적 테이블 Lock
lock table emp in row share mode;
lock table emp in row exclusive mode;
lock table emp in share mode;
lock table emp in share row exclusive mode; lock table emp in exclusive mode;
    ```
    > Oracle Lock 호환성

|      | Null | RS | RX | S | SRX | X |
|:----:|:----:|:--:|:--:|:-:|:---:|:-:|
| NUll | O    | O  | O  | O | O   | O |
| RS   | O    | O  | O  | O | O   |   |
| RX   | O    | O  | O  |   |     |   |
| S    | O    | O  |    | O |     |   |
| SRX  | O    | O  |    |   |     |   |
| X    | O    |    |    |   |     |   |


## 트랜잭션 ##
- 트랜잭션의 특징 : 'ACID'
  - 원자성(Atomicity) : 분해불가 업무 최소단위(All or Nothing)
  - 일관성(Consistency) : 모순되지 않아야 한다.
  - 격리성(Isolation) : 실행중 중간 결과를 타 트랜잭션 접근 불가
  - 영속성(Durability) : 영속적으로 저장.

- 트랜잭션 격리성 : 일관성과 마찬가지로 Lock 과 비례
  > 낮은 단계의 격리성 수준에서 발생할 수 있는 현상들
  - Dirty Read : 아직 커밋되지 않은 데이터를 읽는 것(비일관성)
  - Non-Repeatable Read : 한 트랜잭션 내 같은 쿼리 2번 실행시 타 트랜잭션에서 그 값을 수정 또는 삭제하여 결과가 다르게 나타는 현상(Update, delete)
  - Phantom Read : 한 트랜잭션 내에 같은 쿼리 2번 실행시 유령 레코드가 2번째 쿼리에서 발생하는 현상(Insert)

  > 트랜잭션 격리성 수준: 4가지 트랜잭션 격리성 수준
  - Read Uncommitted : 아직 커밋되지 않은 데이터를 읽는 것을 허용
  - Read Committed : 커밋된 데이터만 읽기 허용
    - Dirty Read 방지 가능
  - Repeatable Read : 트랜잭션 내에 쿼리 2번 실행시 첫번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상 방지
    - Non-Repeatable 방지 가능
  - Serializable Read : 값이 변경되지 않고 새로운 레코드가 나타나지 않음
    - Phantom Read 방지 가능

  > 오라클은 Read Committed, Serializable Read 만 지원 (for update 문으로 Repeatable Read 구현)

  ```sql
  // 트랜잭션 격리성 수준 설정
  set transaction isolation level read serializable;
  ```

  - 동시성 : 다중버전 동시성 제어(스냅샷 격리성 수준 : 현 트랜잭션 수행중에 값이 변경되어도 자신의 수행시점 기준으로 저장된 값을 사용)

## 동시성 제어 ##
동시성과 일관성은 반비례
> 비관적 동시성 제어 vs. 낙관적 동시성 제어
- 비관적 동시성 제어 : 같은 데이터를 동시세 수정 할 것이라고 가정 따라서 읽는 시점에 lock 을 걸고 트랜잭션이 완료될때까지 이를 유지
  - 동시성 저하 위해 for update [nowait|wait 3] 사용
-  낙관적 동시성 제어 : 동시에 수정하지 않을 것이라고 가정 대신 수정 시점에 변경되었는지 검사

> 다중버전 동시성 제어
- 일반적인 Locking 메커니즘의 문제점: 동시성 저하와 일관성 깨짐, 교착상태
- 다중버전 동시성 제어(동시성 일관성 유리 하지만, 오버헤드(Undo블록 I/O, CR Copy, CR 블록 캐싱)
  - 데이터를 변경할때마다 그 변경사항을 Undo 영역에 저장 (Undo 세그먼트)
  - 데이터를 읽다가 쿼리 시작 시점(트랜잭션) 이후에 변경된 값을 발견하면, Undo 영역에 저장된 정보를 이용해 쿼리 시작 시점의 일관성 있는 버전(CR Copy)을 생성하고 그것을 읽음.

> 문장수준 읽기 일관성 : 타 트랜잭션에 의해 데이터가 추가,변경, 삭제가 발생하더라도 단일 SQL문 내에서 일관성 있게 값을 읽는 것을 말한다.

> 트랜잭션 수준 읽기 일관성 : 타 트랜잭션에 의해 데이터가 추가,변경, 삭제가 발생하더라도 트랜잭션 내에서 일관성 있게 값을 읽는 것을 말한다.
- 완벽한 트랜잭션 읽기 일관성을 보장할려면 Serializable Read로 격리성 수준 상승

> Snapshot too old : Undo 영역에 저장된 Undo 정보가 다른 트랜잭션에 의해 재사용돼 필요한 CR Copy 를 생성할수 없을때 발생.
- Undo 영역의 크리 증가
- 불필요한 커밋 사주 수행 않함.
- fetch across commit 형태의 프로그램 작성 피함 : 명시적으로 커서를 열어서 단위 레코드를 fetch 하면서 루프에서 commit 을 날리는 방식
